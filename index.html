<!DOCTYPE html>
<html lang="en" >

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Javascript</title>
</head>
<link rel="stylesheet" href="index.css">
<script type="text/Javascript" src="variabili.js"></script>
<script type="text/Javascript" src="numbers.Js"></script>
<script type="text/Javascript" src="strings.js"></script>
<script type="text/javascript" src="array.js"></script>
<script type="text/javascript" src="statements.js"></script>
<script type="text/javascript" src="function.js"></script>
<script type="text/javascript" src="objects.js"></script>
<script type="text/javascript" src="objects2.js"></script>

<script type="text/Javascript" src="prova.js"></script>

<body>
    <div id="bordo">
        <div class="ph">
            <h1>Inizio</h1>
            <p>
                Per iniziare ad usare Javascript dobbiamo prima aprire sul nostro code editor un foglio HTML e dopodiche
                tra
                i tag head e body aggiungere uno o più tag script. All'interno di questi tag usare gli attributi type e
                src
                per linkare il foglio o i fogli di Javascript.
                <br>
                <img  class="phcode" src="/Media/Photo/Linking Js .png" height="100px" width="400px" alt="Linking Js" class="photo1">
                <br>In questo caso ci sono linkati 3 file di Js ognuno dei quali fa 3 cose ben distinte tra loro.
                <br>In seguito andare sul nostro browser (Chrome, Firefox, Opera, etc.) e aprire la console (ctrl +
                shift +
                j [Windows / Linux] o Cmd + shift +j [Mac]), oppure andare sul documento online → click tasto destro →
                analizza → tab console (shortcut F12).
                <!-- Per aprire una nuova finestra su scrimba: una volta registrati bisogna andare dalla dashboard su My Scrims → 
                cliccare su "+New Scrim" → cliccare su Javascript → create new scrim   -->

            </p>
        </div>
        <div class="ph">
            <h1>Javascript</h1>
            <p>
            <h2>Commenti di Javascript</h2>
            i commenti di Js esattamente come quelli di html e CSS verrano intenzionalmente ignorati e sevono anche
            questi per creare note per te o per altri su cio che il codice fa in quel momento.
            <br> Ci sono due tipi di commenti gli in-line comment e i multiline comment:
            <br> gli in-line comment vengono scritti su una riga e se mandiamo accappo dobbiamo necessariamente ri-fare
            un nuovo commento,<br>
            mentre i commenti multi-line sono utili perchè posso andare accappo senza dover riscrivere un nuovo commento
            <br>[n.d.r. i commenti in-line su Js possono essere creati tramite doppio slash (//) ad inizio commento o
            ctrl + ù,
            mentre per i commenti multi-line devo scrivere /* ad inizio commento e */ a fine commento].
            <br>
            <img class="phcode" src="/Media/Photo/Esempio commenti Js.png" height="160px" width="600px" alt="Esempio commenti Js"
                class="photo1">
            <br>
            <small>Questo è un esempio di in-line comment e multi-line comment</small>
            <br>
            <h2>Data Types e variabili </h2>
            in informatica i data sono qualsiasi cosa ha siginificato per il computer e Js fornisce 7 tipi di data:
            <ol>
                <li>undefined :
                    <br> sono data non definiti, si utilizzano quando ho una variabile che non ho ancora impostato. <br>
                    Quindi sono variabili per cui è avvenuto una allocazione di memoria ma non hanno valore.
                </li>
                <li>null :
                    <br> sono data che non significano nulla (null), si utliizzano quando hai impostato una variabile
                    che non è niente. <br> Quindi è più corretto dire che il codice sa che dovra creare una allocazione
                    di memoria in RAM ma non c'è ancora l'indirizzo in memoria.
                </li>
                <br>La differenza sostanziale tra il null e l'undefined è che null è uno specifico valore che può essere
                assegnato a una variabile per indicare l'assenza intenzionale di un valore dell'oggetto, mentre
                undefined è un valore di default per le variabili non inizializzate
                <li>boolean :
                    <br> siginifica vero o falso o on, off.
                    <br>In javascript i dati booleani rappesentano un valore binario (1,0) che esattamente come il
                    codice binario può avere due valori; vero/falso o meglio dire on/off.
                    <br>Spesso questi valori vengono usati nelle istruzioni condizionali e nel flusso di controllo per
                    prendere decisioni nel codice.<br>
                    Alcuni punti chiave riguardanti i booleani in Js:
                    1. Valori: come menzionato prima le variabili booleane hanno solo due valori; <b>vero o falso</b>.
                    <br>
                    2. Operatori di comparazione: ritornano un valore booleano che è il risutato della comparazione.
                    Ad esempio:
                    <ul type="A">
                        <li>
                            ===(uguaglianza stretta o strict equality): ritorna "vero" se i due valori sono uguali e
                            hanno lo stesso data type
                        </li>
                        <li>
                            !== (disuguaglianza stretta o strict inequality ): ritorna "vero" se i due valori non sono
                            uguali e hanno differenti data type
                        </li>
                        <li>
                            "<" (minore di): ritorna "vero" se l'operando di siinsitra i minore di quello a destra </li>
                        <li>
                            ">" (maggiore di): ritorna "vero" se l'operando di sinistra è maggiore di quello a destra
                        </li>
                        <li>
                            <= (minore di o uguale a): ritorna vero se l'operando di sinistra è minore o uguale
                                dell'operando di destra </li>
                        <li>
                            >= (maggiore di o uguale a): ritorna vero se l'operando di sinistra è maggiore di o uguale
                            a quello di destra
                        </li>
                    </ul>
                    <!-- Tue 28/11/23 13:04: Relative about Comparison Operators -->
                    3.Operatori logici: si possono usare operatori logici per combinare o modificare i valori booleani
                    <ul class="A">
                        <li>
                            && (logical AND): ritorna vero se entrambi gli operandi sono veri
                        </li>
                        <li>
                            || (logical OR): ritorna vero se almeno uno degli operandi è vero
                        </li>
                        <li>
                            ! (logical NOT): ritorna il valore booleano opposto del operando (<div class="esempio">Es:
                            </div> "!true" è "false"
                            viceversa "!false" è "true")
                        </li>
                    </ul>
                    <!-- Tue 28/11/23 13:05: Relative about logical Operators  -->
                </li>
                <li id="strings"> <a href="#str" target="_self">strings</a> :
                    <br>le stringhe sono una sorta di testo, cioè sequenze di caratteri con determinate proprietà.
                    Quindi sono tipi di dati primitivi che vengono usati per rappresentare dati testuali.
                    <br> Su javascript le stringhe vengono create usando le virgolette singole (``:shortcut alt+96 del
                    tastierino numerico) o doppie ("").
                    Javascript tratta le virgolette singole o doppie indifferentemente per creare le stringhe, quindi
                    puoi scegliere lo stile che più ti aggrada.
                    <br>N.B. Le stringhe in Javascript sono immutabili; ovvero una volta create non possono essere
                    cambiate.
                    <br>Tuttavia ci sono diversi metodi per manipolare una stringa, creandone delle nuove basate su
                    quella originale.
                    <br>
                    <div class="esempio">Es: </div>
                    <br>
                    <img class="phcode" src="/Media/Photo/Manipulate original string to create new onepng.png" height="200px"
                        width="500px" alt="" class="photo1">

                </li>
                <li>symbol :
                    <br> è un valore primitivo immutabile che è unico a differneza degli altri dati primitivi (strings,
                    numbers and booleans).
                    <br>Quindi possiamo dire che i simboli sono garantiti per essere unici, e spesso vengono usati come
                    chiavi proprietarie negli oggetti per evitare i conflitti di denominazione.
                </li>
                <li id="number"> <a href="#numb" target="_self">number</a>:
                    <br> sono i numeri, sia interi che frazionari. Quindi sono tipi di dato fondamentali che vengono
                    usati per rappresentare valori numerici.
                    <br>Ci sono diversi aspetti che introduremmo in seguito nel dettaglio.
                </li>
                <li id="object">object :
                    <br> è un oggetto che può memorizzare molte coppie chiave-valore diverse.
                    <br>Nello specifico è un complesso data type che permette di immagazzinare e organizzare dati usando
                    una collezione di coppie chiave-valore.
                    <br>Gli oggetti vengono usati per rappesentare le entità del mondo reale e sono fondamentali parti
                    del linguaggio, possono contenere proprietà e metodi rendedoli una struttura dati versatile.
                    <br>Vengono spesso usati in vari contesti (come ad esempio: rappresentare strutture dei dati, creare
                    classi e instanze, interagire con il DOM[Document Object Model]nel web developement, etc.),
                    comprederli è fondamentale per saper programmare su Js.
                </li>
            </ol>
            Con Js spesso si imposterano i dati di una variabile, una variabile consente ai computer di archiviare e
            manipolare i dati in modo dinamico è fondamentalmente un'etichetta per indicare i dati.
            <br>Possiamo quindi immaginare una variabile come una scatola che può essere riempita con i dati che
            desideri.
            Var definisce variabili, per definire una variabile scrivere var + nome variabile = il suo contenuto dove
            var, per l'appunto, sta per variabile. <br> Ci sono essenzialmente 3 modi per dichiarare una variabile in
            Js:
            var, let, const. Tutti e tre sono usati per dichiarare variabili, e hanno importanti differenze in termini
            di scope, hoisting(la possibilità di dichiarare una variabile anche a fine c ) e mutabilità

            <ol>
                <div id="declare">
                    <li>
                        var :
                        <ul>
                            <li>
                                Le variabili dichiarate con var sono limitate alle funzioni nelle quali sono dichiarate
                            </li>
                            <li>
                                le variabili sono mosse in alto della loro funzione contenitiva o della loro global
                                scope
                                durante la fase di compilazione. Questo può portare a un comportamento inaspettato se
                                non si
                                sta attenti.
                            </li>
                            <li>
                                Si può ri-dichiarare una variabile con var nello stesso ambito, ciò non generare errore
                                quindi
                                può essere utilizzato nell'intero programma.
                            </li>
                            <li>
                                le variabili var non sono block-scoped (locali), quindi possono essere accessibili al di
                                fuori del
                                blocco in cui sono definite.
                            </li>
                        </ul>
                    </li>
                    <li>
                        let : verra utilizzato solo nell'ambito dove lo abbiamo dichiarato, poichè le variabili
                        sdichiarate
                        con let sono block-scoped (locali).
                        <ul>
                            <li>
                                Essendo queste variabili locali sono accessibili nel blocco (diciharazione o istruzione
                                composta) dove sono definite.
                            </li>
                            <li>
                                le variabili let sono sempre hoisted, ma a differenza di var non sono inizializzate fino
                                a
                                che l'interperete raggiunge la linea dove sono dichiarate
                            </li>
                        </ul>
                    </li>
                    <li>
                        const: le variabili dichiarate con il const sono block-scoped come let
                        <ul>
                            <li>
                                la parola chiave const crea variabili che non possono essere ri-assegnate, una volta che
                                la
                                variabile const è assegnata al valore non può essere cambiata.
                            </li>
                            <li>
                                la variabile const deve essere inizializzata durante la dichiarazione.
                            </li>
                        </ul>
                    </li>
            </ol>
        </div>
        N.B. Nello sviluppo moderno di Js, si raccomanda di usare const di default, <br> usare let solo quando si sa
        che il valore della variabile cambierà <br> mentre var è raramente usato di questi tempi, a causa del suo
        comportamento e dei problemi potenziali legati al hoisting e scope.
        <div class="info">
            <img  src="/Media/Photo/lente di ingradimento.jpg" height="40px" width="50px" alt="" class="photo2">
            <h2>Hoisting</h2>
            <p>
                L'hoisting un meccanismo di Js che permette alla variabile e funzione dichiarate di essere spostate
                al top della loro containing scope durante la fase di compilazione, prima che il codice venga
                eseguito.
                <br> Questo siginifica che puoi usare una variabile o chiamare una funzione prima che questa venga
                dichiarata nel codice, senza commettere nessun ReferenceError. <br>
                <mark>Quindi, in parole povere, l'hoisting permette di usare una variabile prima che venga
                    dichiarata</mark>
                Ci sono due grossi aspetti del hoisting in Js:
            <ol type="1.">
                <li>Viariable Hoisting: </li>
                <ul>
                    <li>
                        Quando dichiari una variabile usando var, let o const, la dichiarazione è hoistata al top
                        della corrente funzione o del global scope.
                    </li>
                    <li>
                        Solo la dichiarazione è hoistata, non la inizizalizzazione. Se si vuole inizilalizzare una
                        variabile in seguito nel codice, quella parte non verra hoistata.
                    </li>
                </ul>
                <br>
                <img class="phcode" src="/Media/Photo/Hoisting Variables.png" height="30%" width="40%" alt="" class="photo1">
                <br> <br>
                <li>
                    Hoisting funzione:
                </li>
                <ul class="1.">
                    <li>le dichiarazioni della fuznione sono sempre hoistate al top del loro containing
                        scope(contente l'ambito di aplicazione), e possono essere chiamate prima della loro attuale
                        dichiarazione nel codice. </li>
                    <br>
                    <img class="phcode" src="/Media/Photo/Hoisting function.png" height="40%" width="60%" alt="" class="photo1">
                </ul>
            </ol>
            <mark>è Importante notare che l'hoisting è un comportamento specifico delle dichiarazioni di variabili e
                funzioni, non di assegnazioni di variabili o espressioni di funzione.</mark>
            </p>
        </div>
        </p>
        <H2>Memorizzazione dei valori con l'operatore di assegnazione</H2>
        <p>
            C'è una differenza tra dichiarare una variabile ed assegnarla:
            <br> <br>
            <img class="phcode" src="/Media/Photo/declare and assign a variables.png" height="200px" width="300px" alt=""
                class="photo1">
            <br>A riga 4 sto dichiarando la variabile mentre a riga 7 la sto assegnando, per quanto riguarda la
            seconda variabile, "var b", il segno dell'uguale è l'operatore di assegnazione. Questo siginifica che 2
            viene assegnato a b e non controlla se b = 2, mentre come già detto sopra se vogliamo controllare se b è
            uguale a 2 bisogna aggiungere uno o due uguali. Detto questo dopo l'assegnazione della
            variabile b possiamo assegnare altre variabili, ad esempio alla variabile a possiamo assegnare il numero
            7 (a = 7;). <br>
            [n.d.r. utilizzare sempre il punto e virgola alla fine di un argomento, non è obbligatorio come su CSS
            ma torna utile per la visualizzazione e per capire quando una si è concluso quell'argomento ].
        <div class="info">
            <img src="/Media/Photo/lente di ingradimento.jpg" height="40px" width="50px" alt="" class="photo2">
            <h3>Console.log() command</h3>
            <p>Per visualizzare o stampare dei messaggi e dei valori nella console del browser. Questo commando è
                utile sia per vedere cosa sta facendo il codice in quel momento sia per il debugging che per le
                informazioni di logging.
                <br>
                Per visualizzare l'output del console.log bisogna andare sulla developer console del browser; andare
                sul browser che si sta utilizzando (Firefox, Chrome, Safari, etc.) → cliccare il tasto destro del
                mouse (shortcut F12) → andare sulla voce analizza → tab console.
                <br>
                Andiamo ad elencare le diverse funzionalità del commando console.log
            <ol type="1.">
                <li>
                    Visualizzare i messaggi:
                    <br> Si può usare console.log () per visualizzare i messaggi e il testo nella console.
                    <br> Ciò è utile per fornire un feedback e un informazione riguardo a cosa sta facendo il
                    codice.
                    <br>
                    <div class="esempio">Es: </div> <br>
                    <img class="phcode" src="/Media/Photo/console.log(message).png" alt="" class="photo1">
                </li>
                <li>
                    Variabili e valori di logging:
                    <br>si può loggare i valori delle variabili, espressioni o le strutture di dati per analizzare
                    il loro stato corrente.
                    <br>Ciò è molto utile per il debugging e per capire il comportamento del codice.
                    <br>
                    <div class="esempio">Es: </div>
                    <br>
                    <img class="phcode" src="/Media/Photo/console.log(variabili e valori di logging).png" height="100px" width="400px"
                        alt="" class="photo1">
                </li>
                <li>
                    L'ispezioni di oggetti:
                    <br>si possonono loggare le proprietà e i valori degli oggetti e arrays, rendendo più facile
                    ispezionare il loro contentuto
                    <br>
                    <div class="esempio">Es: </div>
                    <br>
                    <img class="phcode" src="/Media/Photo/l'ispezioni di oggetti del console.log.png" height="100px" width="490px"
                        alt="" class="photo1">
                </li>
                <li>
                    Errori di logging:
                    <br>Nel caso si verifichi un errore nel codice lo si può loggare tramite il console.log().
                    Quindi trmaite questo comando si loggano messaggi di errore, stack traces(è una lista di
                    funzioni che mostra la sequenza di invocazioni di funzioni che ha portato a un errore o
                    un'eccezzione), e altre informationi rilevanti per aiutare la diagnosi e per ovviare ai
                    problemi.
                    <br>
                    <div class="esempio">Es: </div>
                    <br>
                    <img class="phcode" src="/Media/Photo/Console.log(Errori di logging).png" height="100px" width="490px" alt=""
                        class="photo1">
                </li>
                <li>
                    Interagire con la console:
                    <br>oltre al logging, la console fornisce altri metodi come:
                    <ul>
                        <li>
                            console.warn()
                        </li>
                        <li>
                            console.error()
                        </li>
                        <li>
                            console.info().
                        </li>

                    </ul>
                    Questi tre metodi sono utili per distinguere differenti tipi di output.
                    <br>
                    <div class="esempio">Es: </div>
                    <br>
                    <img class="phcode" src="/Media/Photo/console.log(interagire con la console).png" height="100px" width="490px"
                        alt="" class="photo1">
                </li>
                <li>
                    Logging Condizionale:
                    <br>si può condizionalmente loggare messaggi basati su certe codinzioni o flags. <br>
                    Ciò è utile per selettivamente abilitare o disabilitare l'output del debug.
                    <br>
                    <div class="esempio">Es: </div>
                    <br>
                    <img class="phcode" src="/Media/Photo/console.log(logging condizionale).png" height="100px" width="490px" alt=""
                        class="photo1">
                </li>
            </ol>
            </p>
        </div>
        <br>

        </p>
        <h2>inizializzazioni delle variabili con l'operatore di assegnazione e variabili non inizializzate </h2>
        <p>
            Per inizializzare una variabile scrivere
            <br>var/let/const a = 9.
            <br>Quindi, come detto in precedenza, var/let/const dichiarano la variabile e =9 la inizializza con
            l'operatore di assegnazione (=).
            <br>Per quanto riguarda la variabili non inizializzate, diciamo che ho dichiarato 3 variabili non
            inizializzate
            <br>
            <br>
            <img class="phcode" src="/Media/Photo/declare uninitialized Variables.png" height="150px" width="200px" alt=""
                class="photo1">
            <br>adesso devo inizializzare e per fare ciò scrivo l'operatore di assegnazione su ciascuna variabile
            assegnando dei valori
            <br>
            <br>
            <img class="phcode" src="/Media/Photo/uninitialized variables.png" height="400px" width="200px" alt="" class="photo1">
            <br>una volta inizializzate, dalla riga 14 alla 16 ho assegnato dei vlaori aggiuntivi a tutti e tre;
            cioè a =4 + 1 = 5, b = 5 + 5 = 10 c = "I am" + "string" = "I am string".
            <br>[n.d.r. Ricorda che le variabili in js sono case sensivity,cioè:
            <br> dichiariamo var PiPPosolo;
            <br> dopodichè assegniamo un valore riscrivendola PIPPOSOLO = 120;
            <br> se provassimo al logare l'asseganzione della variabile su console ci darebbe errore perchè non
            definità per js poichè entrambi le variabili sono scritte in modo diverso. Si consiglia di usare il
            camelCase(
        <div class="esempio">Es: </div> pippoSolo)]
        </p>
        <br>
        <h2 id="numb"> <a href="#number" target="_self">Numbers</a> </h2>
        <p>Come già detto sopra i numeri sono dati primitivi fondamentali per rappresentare i valori numerici in
            Javascript, hanno varie funzionalità e caratteristiche e possono essere usati sempre nell'ambito
            aritmetico.
            <br>
            Le diverse caratteristiche dei numeri in Js sono le seguenti:
        <ol type="1.">
            <li>
                Number Data Type:
                <ul>
                    <li>Si possono fare le diverse operazioni aritmetiche</li>
                    <li>Javascript ha un singolo data type numerico,
                        detto per l'appunto <b>"Number"</b></li>
                    <li>I numeri possono avere valori interi (integers) o con la virgola (floating point)</li>
                    <br>
                    <br><img class="phcode" src="/Media/Photo/Numeri interi e decimali.png" height="40%" width="40%" alt=""
                        class="photo1">
                </ul>
            </li>
            <li>
                Operazioni aritmetiche:
                <ul>
                    <li>Si possono fare le diverse operazioni aritmetiche</li>
                    <br><img class="phcode" src="/Media/Photo/operazioni aritmetiche js.png" height="40%" width="40%" class="photo1"
                        alt="operazioni aritmetiche">
                </ul>
            </li>
            <li>Incrementare i numeri
                <ul>
                    <li>posso incrementare i numeri in 2 modi; </li>
                    <br><img class="phcode" src="/Media/Photo/incrementare numeri js.png" height="10%" width="20%" alt=""
                        class="photo1">
                    <br> come possiamo vedere con questo metodo ho incrementato il valore della mia variabile di +1
                    valore, <br>
                    <li>il secondo metodo è;</li>
                    <br><img class="phcode" src="/Media/Photo/incrementare numeri in js 2.png" height="10%" width="20%" alt=""
                        class="photo1">
                </ul>
                N.B. se volessi incrementare il valore della variabile numerica di 2 valori o più
                <br><img class="phcode" src="/Media/Photo/Incrementare numeri js 3.png" height="10%" width="20%" alt="" class="photo1">
            </li>
            <li>Decrementare i numeri:
                <br>
                L'operazione da fare è l'inversa della incrementazione, cioè;
                <br><img class="phcode" src="/Media/Photo/Decrementare i numeri js.png" height="10%" width="20%" alt="" class="photo1">

                N.B.Se volessi sempre decrementare i numeri di 2 o più valori l'operazione è la stessa della
                incrementazione, ma con il segno meno
            </li>
            <li>trovare il resto (modulo):
                <br>Per trovare il resto (detto modulo) della divisione di 2 numeri bisogna usare l'operatore di
                resto (%);
                <br><img class="phcode" src="/Media/Photo/Remainder.png" height="20%" width="20%" alt="" class="photo1">
                <br>L'operatore di resto viene spesso utilizzato per determinare se un numero è pari o dispari, se
                vuoi
                dividere un numero per 2 e il resto è 0 allora siginfica che il numero è pari
            </li>
            <li>
                Assegnazione composta con aggiunta aumentata:
                <br>Se volessimo aggiungere un valore ad una variabile numerica dovremmo riscrivere let numb1=3,
                numb1=numb1 + 7;
                <br> tuttavia essendo una operazione molto comune esiste una scorciatoia per fare ciò
                <br><img class="phcode" src="/Media/Photo/Assegnazione composta con aggiunta aumentata.png" height="20%" width="20%"
                    alt="">
            </li>
            <li>Assegnazione composta con sottrazione aumentata:
                <br>se la scorciatoia += aumenta il valore, -= fa la cosa inversa
                <br><img class="phcode" src="/Media/Photo/Assegnazione composta con sottrazione aumentata.png" height="20%" width="20%"
                    alt="">
            </li>
            <li>Assegnazione composta con moltiplicazione aumentata:
                <br>lo shortcut *= moltiplica i valori di una variabile
                <br><img class="phcode" src="/Media/Photo/Assegnazione composta con moltiplicazione aumentata.png" height="20%"
                    width="20%" alt="">
            </li>
            <li>Assegnazione composta con divisione aumentata:
                <br>lo shortcut /= divide i valori di una variabile
                <br><img class="phcode" src="/Media/Photo/Assegnazione composta con divisione aumentata.png" height="20%" width="20%"
                    alt="">
            </li>
            <li>Math object:
                <br>Javascript provede un oggetto Math che contiene una varieta di funzioni e costanti
                matematiche,<br>
                queste funzioni permettono di eseguire varie operazioni matematiche nel codice di Js. <br>
                I metodi più usati sono
                <ul type="A">
                    <li>Math.PI:
                        <br>ritorna la costante matematica π (pi o pi greco).
                        <br>
                        <br><img class="phcode" src="/Media/Photo/Math.PI.png" height="20%" width="20%" alt="">
                    </li>
                    <br>
                    <li>
                        Math.round(x):
                        <br>arrotonda il numero per eccesso o per difetto in base al numero dopo la virgola
                        <br>
                        <br><img class="phcode" src="/Media/Photo/Math Round.png" height="30%" width="40%" alt="">
                        <br>N.B. dal valore dopo la virgola .5 math round arrotonda per eccesso sotto il .5
                        arrotonda per difetto
                    </li>
                    <br>
                    <li>Math.floor:
                        <br>arrotonda per difetto
                        <br>
                        <br><img class="phcode" src="/Media/Photo/Math.floor.png" height="30%" width="30%" alt="">
                    </li>
                    <br>
                    <li>Math.ceil(x):
                        <br>arrotonda per eccesso
                        <br>
                        <br><img class="phcode" src="/Media/Photo/Math.ceil.png" height="30%" width="30%" alt="">
                    </li>
                    <br>
                    <li> Math.random(x):
                        <br>Ritorna a un pseudo numero casuale con la virgola compreso tra 0(inclusivo) e 1
                        (esclusivo).
                        <br>
                        <br><img class="phcode" src="/Media/Photo/Math.random.png" height="30%" width="30%" alt="">
                        <br>N.B. ogni volta che fai correre questa proprietà crea in modo randomico un numero con la
                        virgola diverso
                    </li>
                    <br>
                    <li>Math.sqrt(x)
                        <br>fa la radice quadrata di un numero
                        <br>
                        <br><img class="phcode" src="/Media/Photo/Math.sqrt.png" height="30%" width="30%" alt="">
                    </li>
                    <br>
                    <li>
                        Math.pow(x,y):
                        <br>Ti permette di fare le potenze; il primo numero (x) è il numero che va elevato, il
                        secondo numero (y) è la potenza
                        <br>
                        <br><img class="phcode" src="/Media/Photo/Math.pow.png" height="40%" width="50%" alt="">
                    </li>
                    <br>
                    <li>Math.sin(x), Math.cos(x), Math.tan(x):
                        <br>permette di fare rispettivamente il seno, il coseno e la tangente di un angolo in
                        radianti.
                        <br>
                        <br><img class="phcode" src="/Media/Photo/Math.sin.png" height="50%" width="40%" alt="">
                    </li>
                    <br>
                    <li>Math max(x, y, ...):
                        <br>Restituisce il numero più grande tra quelli forniti
                        <br>
                        <br><img class="phcode" src="/Media/Photo/Math.max.png" height="30%" width="30%" alt="">
                    </li>
                    <br>
                    <li>Math.min (x,y,...):
                        <br>Restituisce il numero più piccolo tra quelli forniti
                        <br>
                        <br><img class="phcode" src="/Media/Photo/Math.min.png" height="30%" width="30%" alt="">
                    </li>
                    <br>
                    <li></li>
                    <br>
                </ul>
            </li>
            <li>Nan (Not a Number):
                <br>NaN sta per "not a number", è un valore speciale che rappesenta un non rappresentabile o non
                definito valore numerico. <br>NaN è spesso il risultato di un operazione che include dei valori
                numerici
                non definto o non numerico.
                <br>Gli scenari più comuni quando si usa NaN sono:
                <ul type="A">
                    <li>
                        Operazioni matematiche non definite o non rappresentabili:
                        <br>
                        <div class="esempio">Es: </div> let division = 10 / "abc"; è NaN
                    </li>
                    <br>
                    <li>
                        Operazioni matematiche con valori non definiti:
                        <br>
                        <div class="esempio">Es: </div> Let square root = Math.sqrt(-1); è NaN
                    </li>
                    <br>
                    <li>Usare NaN esplicitamente:
                        <br>
                        <div class="esempio">Es: </div> Let numb=NaN;
                    </li>
                    <br>Per controllare se il valore è NaN si possono usare 2 funzion:
                    <ul type="I">
                        <li>isNaN():
                            Tuttavia bisogna stare attenti poichè isNaN ha alcune stranezze; costringe il suo
                            argomento a diventare un numero prima
                            di effettuare il controllo.
                            <br>
                            <div class="esempio">Es: </div> isNaN("Hello"); è vero, <br> isNaN(123); è falso
                        </li>
                        <br>
                        <li>
                            Number.isNaN():
                            <br>è il metodo più affidabile poichè non attua coercizioni
                        </li>
                    </ul>
                </ul>
                <br>
            </li>
            <li>Infinity and -Infinity:
                <br>rappresentano, rispettivamente, l'infinito poisitivo e negativo. Questi sono valori speciali che
                rappesentano l'infinito matematico, in questo caso spesso sono i risultati delle operazioni che
                vanno oltre il range dei valori rappresentabili in Js.
                Gli scenari più comuni sono:
                <ul type="A">
                    <li>divisioni dello zero:
                        <br>
                        <div class="esempio">Es: </div> Let division= 1/0; è infinito
                    </li>
                    <br>
                    <li>Moltiplicare o dividere un numero finito per l'infinito positivo o negativo:
                        <br>
                        <div class="esempio">Es: </div> console.log(5 * Infinity); // Infinity
                        console.log(-10 / Infinity); // -0
                    </li>
                    <br>
                    <li>Operazioni matematiche che vanno oltre il range rappresentabile:
                        <br>
                        <div class="esempio">Es: </div> console.log(Math.pow(10, 1000)); // Infinity
                    </li>
                </ul>
                <br> Si puo fare un check per "infinity" o "-infinity" usando la funzione "isFinite()":
                <br>
                <div class="esempio">Es: </div>isFinite(positiveInfinity); // false
                isFinite(negativeInfinity); // false
                isFinite(5); // true
                <br>Da notare che "isFinite" diventa falso sia per "infinity" e "-infinity".
                Tutto Questo può essere utile nel caso in cui io voglia prevenire comportamenti non intenzionali nel
                codice, a causa di operazioni che danno come risultato l'infinito.
            </li>
            <li>
                Parse & Convert :
                <br>i termini "parse" e "convert" sono spesso usati nel contesto della lavorazione dei dati;
                specialmente quando si tratta di stringhe o numeri.
                Per quanto riguarda il parsing abbiamo due caratteristiche:
                <ul type="A">
                    <li>
                        Parse strings to number:
                        <br>"ParseInt()" e "ParseFloat()" sono due funzioni che vengono usata per convertire,
                        rispettivamente, le stringhe in numeri interi o con la virgola.
                        <br>
                        <div class="esempio">Es: </div>
                        <br>let numericString = "123";<br>
                        let numericValue = parseInt(numericString);<br>
                        console.log(numericValue); // 123
                        <br>
                        <br>
                        let floatString = "3.14";<br>
                        let floatValue = parseFloat(floatString);<br>
                        console.log(floatValue); // 3.14

                    </li>
                    <br>
                    <li>JSON Parsing:
                        <br>il metodo JSON.Parse() viene usato per analizzare (parsing) a stringa JSON e convertirla
                        in un oggetto di JS.
                        <br>
                        <div class="esempio">Es: </div>
                        <br>let jsonString = '{"name": "John", "age": 30}';<br>
                        let parsedObject = JSON.parse(jsonString);<br>
                        console.log(parsedObject.name); // John
                        <br>
                        <br>
                        <div class="info">
                            <img src="/Media/Photo/lente di ingradimento.jpg" height="40px" width="50px" alt="">
                            <h3>Parsing</h3>
                            <br>
                            <p>
                                Il termine Parsing in inglese sta per "interpretare/analizzare",
                                <br><mark>è spesso riferito al processo di analisi o interpretazione dei dati, in
                                    modo particolare quando si tratta di strighe o di testo. </mark>
                            </p>
                        </div>
                        <br>
                        <ul type="A">
                            Invece per quanto riguarda la conversione in Js abbiamo 3 metodi:
                            <li>
                                Convertire i numeri alle stringhe:
                                <br>per convertire un numero in una stringa bisogna usare il metodo "toString()" o
                                mediante la concatenazione di una stringa vuota.
                                <br>
                                <div class="esempio">Es: </div>
                                <br>let number = 42;
                                <br>let stringNumber = number.toString();
                                <br>console.log(stringNumber); // "42"
                            </li>
                            <br>
                            <li>
                                Convertire in Booleano:
                                <br>I valori in Js possono essere implicitamente convertiti in booleani in certi
                                contesti (ad esempio negli statements condizionali).
                                <br>Si può usare la funzione "Boolean()" per la conversione esplicita.
                                <br>
                                <div class="esempio">Es: </div>
                                <br>let truthyValue = "Hello";
                                <br>let booleanValue = Boolean(truthyValue);
                                <br>console.log(booleanValue); // true
                            </li>
                            <br>
                            <li>
                                Convertire in un array:
                                <br>è possibile convertire oggetti simili e iterabili(ad esempio stringhe o
                                NodeLists) in arrays, usando "Array.from" o lo spread generator "..."
                                <br>
                                <div class="esempio">Es: </div>
                                <br>let iterableString = "hello";
                                <br>let charArray = Array.from(iterableString);
                                <br>console.log(charArray); // ["h", "e", "l", "l", "o"]
                            </li>
                            <br>
                        </ul>
                    </li>
                    <br>
                </ul>
                La differenza tra parse e convert è che: il convert converte i tipi di dati o rappresentazioni;
                quindi nel pratico quando converti un numero cambia il numero.
                <br>Mentre il parse cambia l'azione; cioè crea una copia leggibile in un altro modo per il numero.
            </li>
            <br>
            <li>
                Number to string conversion:
                <br>ti permette di convertire un numero in una stringa.
                <br>I metodi più usati sono:
                <ul type="A">
                    <li>
                        Usare il metodo to.String:
                        <br>
                        <div class="esempio">Es: </div>
                        <br>let myNumber = 42;
                        <br>let myString = myNumber.toString();
                        <br>console.log(typeof myNumber); // Output: number
                        <br>console.log(typeof myString); // Output: string
                    </li>
                    <br>
                    <li>
                        Concatenazione con una stringa vuota:
                        <br>
                        <div class="esempio">Es: </div>
                        <br>let myNumber = 123;
                        <br>let myString = '' + myNumber;
                        <br>console.log(typeof myNumber); // Output: number
                        <br>console.log(typeof myString); // Output: string
                    </li>
                    <li>Usare la funzione "String()":
                        <br>
                        <div class="esempio">Es: </div>
                        <br>let myNumber = 3.14;
                        <br>let myString = String(myNumber);
                        <br>console.log(typeof myNumber); // Output: number
                        <br>console.log(typeof myString); // Output: string
                    </li>
                    <br>Tutti questi metodi convertirano i numeri alla loro rappresentazione come stringa. Sono
                    tutti validi, bisogna solo scegliere quello che troviamo piu leggibile o conveniente per il
                    nostro utilizzo in un caso specifico.
                </ul>
            </li>
            <br>
            <li>Number Methods:
                <ul type="A">
                    <li>toFixed():
                        <br>Formatta un numero usando la notazione del punto fisso.
                        <br>
                        <div class="esempio">Es: </div>
                        <br>let myNumber = 3.14159;
                        <br>let formattedNumber = myNumber.toFixed(2); // Rounds to 2 decimal places
                        <br>console.log(formattedNumber); // Output: "3.14"
                    </li>
                    <li>toPrecision:
                        <br>Formatta il numero con una precisione specificata.
                        <br>
                        <div class="esempio">Es: </div>
                        <br>let myNumber = 123.456789;
                        <br>let formattedNumber = myNumber.toPrecision(5); // Total digits including integer and
                        decimal parts
                        <br>console.log(formattedNumber); // Output: "123.46"
                    </li>
                    <li>toExponential():
                        <br>Converte un numero in notazione esponenziale.
                        <br>
                        <div class="esempio">Es: </div>
                        <br>let myNumber = 12345;
                        <br>let exponentialNumber = myNumber.toExponential(2); // 2 decimal places in exponential
                        notation
                        <br>console.log(exponentialNumber); // Output: "1.23e+4"
                    </li>
                </ul>
            </li>
            <br>
        </ol>
        </p>
        <h2 id="str"> <a href="#strings" target="_self">Strings</a></h2>
        <p>
            Come accenato prima le stringhe in Javascript sono una sequenza di caretteri che sono usati per
            rappesentare e manipolare un testo, si creano usando le virgolette singole(''), le virgolette doppie("")
            o le backsticks(``: shortcut alt + 96 del tastierino numerico).
            <br>Ci sono alcuni metodi basici che si possono eseguire con le stringe in Js.
            <br>!! <mark>Le stringhe in Javascript sono immutabili, cioè una volta create non possono essere
                cambiate</mark>!!
            <br>Tuttavia si può creare una nuova stringa basandosi su un'altra esistente attraverso la
            concatenazione o usando metodi che restituiscono nuove stringhe.
            <br>I metodi sono vari e numerosi, qui ci sono quelli più comuni:
        <ol type="1.">
            <li>Dichiarare la stringa:
                <br>Dichiare una variabile (Es: let str) poi con l'operatore di assegnazione si assegna un valore a
                quella stringa.
                <br>
                <div class="esempio">Es: </div>
                <br>let str =`Hello World`
            </li>
            <br>
            <li>Caratteri di fuga:
                <br>Tutto ciò che è contenuto nelle virgolette viene cosiderata una stringa nel codice di Js, se
                scrivessi dei caratteri al di fuori delle virgolette non verebbero considerati:
                <div class="esempio">Es:
                    <br>let str = "I am" double quoted"string"double quotes""
                </div>
                <br>Per ovviare a questo problema c'è una cosa chiamata carattere di fuga:
                <br>è usato per rappresentare caratteri che non sono facilmente tipizzati o visibili, questo
                carattere è rappresetato da un backslash "\".
                I più comuni sono:
                <ul type="A">
                    <li>Newline (\n):
                        è comunemente usato per inserire una nuova linea o mandare accapo una stringa.
                        <div class="esempio">Es:
                            <br>var myString = "This is the first line.\nThis is the second line.";
                            <br>console.log(myString); //Output is : This is the first line.
                            <br>This is the second line.
                            <br>
                        </div>
                    </li>
                    <br>
                    <li>Carriege return(\r):
                        è usato per muovere il cursore all'inizio della linea senza farlo avvanzare alla prossima
                        linea.
                        <br>
                        <div class="esempio">Es:
                            <br>var myString = "This is some text.\rThis text will overwrite the previous line.";
                            <br>console.log(myString);
                            <br>This is some text.
                            <br>This text will overwrite the previous line.
                        </div>
                        Quindi il carriage return cuasa la sovrascrittura della seconda parte della stringa sulla
                        stessa linea. Tuttavia il carriage return, in tempi moderni, è il meno usato ma lo si
                        potrebbe incontrare quando si lavora con certi formati basati su testo o quando si ha a che
                        fare con convenzioni di nuova riga specifiche della piattaforma.
                    </li>
                    <br>
                    <li>tab character(\t):
                        è usato per creare spazi bianchi orizzontali, tipicamente equivalenti a un certo numero di
                        spazi.
                        <div class="esempio">Es:
                            <br>var myString = "This is some text.\tThis text is indented with a tab.";
                            <br>console.log(myString);
                            <br>This is some text. This text is indented with a tab.
                        </div>
                        In questo esempio il tab character è usato tra le due parti di una stringa, creando cosi un
                        effetto di indentazione. Ciò può tornare utile quando si vuole formattare l'output o
                        organizzare il testo in un modo che richiede uno spazio consistente.
                    </li>
                    <br>
                    <li>backspace character(\b):
                        è usato per muovere il cursore di una posizione; cioè cancellando il carattere a quella
                        posizione
                        <div class="esempio">Es:
                            <br>var myString = "Hello\b World!";
                            <br>console.log(myString);
                            <br>Hel World!
                        </div>
                        Nell'esempio lo space character causa una sovrascrittura dei caratteri 'o' ed 'l' in
                        'Hello', cosi che l'output risulti "Hel World". Tuttavia il carattere di backspace non è
                        comunemente usato nel development moderno per le interazioni dell'interfaccia utente. Lo si
                        può incotrare quando si ha a che fare con certi formati basati su testo o in scenari laddove
                        si ha la necessità di manipolare i caratteri in una stringa.
                    </li>
                    <br>
                    <li>backslash (\):
                        <br>è usato per evitare una virgoletta andnado così andando indicare che non sara più la
                        fine di una stringa (funziona sia con le virgolette singole che doppie).
                        <br>
                        <div class="esempio">Es:
                            <br>let mystr = "I am \"double quote\"string\"double quotes"
                            <br>console.log(mystr)//Output: I am "double quote"string"double quotes
                        </div>
                        Un altra cosa che posso fare è che se volessi aggiungere le backslash nella mia stringa devo
                        per forza metterne due perche la prima va ad indicare l'escape character.
                        <div class="esempio">Es:
                            <br>var myString = "This is a backslash: \\";
                            <br>console.log(myString);
                            <br>This is a backslash: \
                        </div>
                        questo è particolarmtente Importante quando si ha a che fare con percorsi file o espressioni
                        regolari dove le backslashes sono usate come caratteri speciali e hanno bisogno di
                        "scappare"
                    </li>
                    <li>Single Quotes escape character ('\'):
                        <br>serve per includere una virgoletta singola in una stringa che a sua volta è già inclusa
                        in delle virgolette singole.
                        <br>
                        <div class="Esempio">Es:
                            <br>var myString = 'This is a single quote: \'';
                            <br>console.log(myString);
                            <br>This is a single quote: '
                        </div>
                    </li>
                    <br>
                    <li>Double quotes escape character ('\"'):
                        <br>stessa cosa delle Single Quotes escape character ma con le viroglette doppie
                        <br>
                        <div class="esempio">Es:
                            <br>var myString = "This is a double quote: \"";
                            <br>console.log(myString);
                            <br>This is a double quote: "
                        </div>
                    </li>
                    <br>
                    <li>Form feed (\f):
                        <br>è usato per far avanzare il cursore alla prossima pagina o linea su alcuni sistemi.
                        <br>
                        <div class="esempio">Es:
                            <br>console.log("This is a text with a form feed character\fNext line of text.");
                            <br>This is a text with a form feed character
                            <br>Next line of text.
                        </div>
                        N.B. il risultato dell'output può dipendere su dove fai uscire il testo (console, HTML,
                        etc.), quindi l'effetto del form feed dipende dall'ambiente nel quale è visualizzato.
                        <br>Negli ambienti moderni il carattere di form feed puo comportarsi in maniera simile al
                        carattere di newline.
                    </li>
                </ul>
            </li>
            <br>
            <li>Lenght:
                <br>Restituisce la lunghezza di una stringa.
                <br>
                <div class="esempio">Es: </div>
                <br><img src="/Media/Photo/string.length.png" height="200px" width="600px" alt="">
                <br><small>Note: i caratteri presenti nella mia stringa in totale sono di 41 caratteri</small>
                <br>
                <br>N.B.quando si parla dei caratteri delle stringhe si includono pure gli spazi e la puntegiattura.
                Inoltre la length non è un metodo ma un oggetto della stringa poiche si accede direttamente con la
                notazione del punto (`string.length`), anziche usando le parentesi come si fa per i metodi.
                <br>Un altra cosa da sapere è che se vuoi trovare i caratteri di una stringa, in termini dell'unità
                di codice UTF-16, si usa l'oggetto length.
                <br> Mentre se si vuole sapere l'attuale numero di caratteri (considerando i caratteri Unicode che
                possono essere composti da più unità di codice), si usa l'oggetto `Intl`.
                <!-- let myString = "😊🌍"; // A string with emoji and a globe character
                    console.log(myString.length); // Outputs 4 (UTF-16 code units)
                    console.log([...myString].length); // Outputs 2 (actual number of characters), 
                    notare come funziona con gli emoji ma non con i caratteri canonici, perche? -->
            </li>
            <br>
            <li>Accedere ai caratteri:
                <br>Si può accedere individualmente ai caratteri tramite l'annotazione tra parentesi quadre.
                <br>l'indice di questa numerazione parte da 0 ovvero per accedere al primo carattere si scrive 0,
                per il secondo 1, per il terzo 2,etc.
                <br>
                <div class="esempio">Es: </div> let str = 'Hello, World!';
                <br>console.log(str[0]); // Outputs 'H'
                <br>Un altro metodo è il "charAt()":
                <br>
                <div class="esempio">Es: </div>
                <br>let myString = "Hello, World!";
                <br>let firstCharacter = myString.charAt(0);
                <br>console.log(firstCharacter); // Output: H.
                <br>N.B. tra i due non c'è differenza, l'unica cosa è che le parentesi quadre sono più concise e per
                questo sono il metodo preferito nel moderno Js.
                <br>
                <br>
                <div class="info">
                    <img src="/Media/Photo/lente di ingradimento.jpg" height="40px" width="50px" alt="">
                    <h3>Il metodo .charCodeAt</h3>
                    <p>
                        questo metodo in Js è usato per prendere il valore Unicode dei caratteri a uno specifico
                        index nelle stringhe:
                        <br>
                    <div class="esempio">Es</div>:
                    <br>let myString = "Hello, World!";
                    <br>let charCode = myString.charCodeAt(0);
                    <br>console.log(charCode); // Output: 72
                    <br>Come possiamo vedere nell'esempio viene riportato come output il valore Unicode del
                    carattere all'index 0, che è "H", ma nell'Unicode il valore per "H" è 72.
                    <br>Anche questo metodo parte dallo zero, quindi "myString.charCodeAt(1)" ti potrebbe dare
                    il valore di Unicode del carattere all'index 1, e cosi via.
                    <br>
                    <div class="Tips">
                        <img src="/Media/Photo/EF.jpg" height="80px" width="70px" alt="">
                        <h4>Tips & Tricks</h4>
                        <p>Se volessi dare i valori Unicode per tutti i caratteri in una stringa, li posso loopare
                            attraverso la stringa stessa:
                            <br>
                        <div class="esempio">Es: </div>
                        <br>let myString = "Hello, World!";
                        <br>for (let i = 0; i < myString.length; i++) { <br>console.log(myString.charCodeAt(i));
                            }
                            </p>
                    </div>
                    Benchè siano quasi simili in scrittura, esiste una differenza tra i metodi ".charAt()" e
                    ".charCodeAt()":
                    <ol type="1.">
                        <li id="charAt"> <a href="#bN" target="_blank">"charAt(index)":</a>
                            <ul>
                                <li>
                                    Purpose: Restituisce il carattere allo specifico index in una stringa
                                </li>
                                <li>
                                    Return type: Restituisce una stringa contenente il carattere
                                </li>
                                <li>
                                    <div class="esempio">Es: </div>
                                    <br>let myString = "Hello, World!";
                                    <br>let character = myString.charAt(0);
                                    <br>console.log(character); // Output: H
                                </li>
                            </ul>
                        </li>
                        <li id="charCodeAt"> <a href="#bN" target="_blank">"charCodeAt(index)":</a>
                            <ul>
                                <li>Purpose: Restituisce il valore Unicode (intero) del carattere allo specifico
                                    index in una stringa</li>
                                <li>Return Type: Rstituisce un integer che rappresenta il vlaore Unicode </li>
                                <li>
                                    <div class="esempio">Es: </div>
                                    <br>let myString = "Hello, World!";
                                    <br>let charCode = myString.charCodeAt(0);
                                    <br>console.log(charCode); // Output: 72 (Unicode value for 'H')
                                </li>
                            </ul>
                        </li>
                    </ol>
                    In sostanza ".charAt()" restituisce il carattere in se, mentre ".charCodeAt" restituisce il
                    valore Unicode del carattere allo specifico Index.
                    </p>
                </div>
            </li>
            <br>
            <li>String extraction methods:
                <br>in Js ci sono diversi metodi per estrarre parti di stringhe:
                <ul type="A">
                    <li>
                        '.substring(start index, end index)':
                        è un metodo usato per estrarre una porzione di una stringa e restituisce l'estrazione della
                        sottostringa.
                        Ci sono due parametri nell'argomento;
                        <br>l'index di inizio e l'index di fine,
                        <br>
                        <div class="esempio">Es:
                            <br>let str = "Hello, World!";
                            <br>let subStr = str.substring(0, 5); // Returns "Hello"
                        </div>
                        Come possiamo vedere dall'esempio il metodo 'substring' viene usato per estrarre i caratteri
                        dall'index 0 al 4 (l'index 5 non viene incluso nell'estrapolazione), difatti la sotto
                        stringa che estrappolata sarà tutta la frase "hello".
                        <br>se si vuole prendere fino alla fine al carattere specificato non si aggiunge il secondo
                        argomento
                        <div class="esempio">Es:
                            <br>let str =`Hello World`
                            <br>let substring = str.substring(0)
                            <br>console.log(substring) //Output:'Hello world'
                        </div>
                        <br>è importante notare che il metodo 'substring' non modifica la stringa originale, invece
                        se lo si volesse fare è necessario riassegnare il risultato alla variabile
                        <div class="esempio">Es:
                            <br>let str = "Hello, World!";
                            <br>str = str.substring(0, 5); // Now, str is "Hello"
                        </div>
                        <br> è bene sapere anche che nel caso in cui l'indice di inzio sia più grande dell'indice di
                        fine, il metodo 'substring' cambierà i due indici
                        <br>
                        <div class="esempio">Es:
                            <br>let str = "Hello, World!";
                            <br>let subStr = str.substring(7, 2); // Returns "llo, "
                        </div>
                        <br>come possiamo ben vedere inizia dall'index 2 e finisce all'index 6 perchè il 7 non viene
                        incluso.
                        <br>N.B.Se invece volessi inserire numeri negativi come parametri di substring ritorna
                        stringa
                        vuota.
                        <div class="esempio">Es:
                            <br>let str =`Hello World`
                            <br>let substring = str.substring(-7,-13)
                            <br>console.log(substring) // No Output
                        </div>
                    </li>
                    <br>
                    <li>'.slice(start index, end index)':
                        <br>il metodo slice è usato per estrarre una porzione di una stringa e restituire la sotto
                        stringa estratta. Come per il substring si hanno due paremetri; l'index di inizio e fine.
                        <br>La stringa originale non è modificata, invece viene restituita una nuova stringa
                        contenente la porzione specificata.
                        <div class="esempio"> Es:
                            <br>let str = "Hello, World!";
                            <br>let subStr = str.slice(0, 5); // Returns "Hello"
                        </div>
                        In questo esempio, il metodo slice è usato per estrarre i caratteri dall'index 0 al 4 (5
                        escluso), cosicché l'output sarà "hello".
                        <br>Il metodo 'slice' accetta anche indici negativi; peremttendoti di contare la posizione
                        dalla fine della stringa.
                        <br>
                        <div class="esempio">Es:
                            <br>let str = "Hello, World!";
                            <br>let subStrEnd = str.slice(-6); // Returns "World!"
                        </div>
                        <br>In questo caso il metodo 'slice' estrae gli ultimi 6 caratteri della stringa, partendo
                        dalla fine.
                        <br>Come per 'substring', 'slice' non modifica la stringa originale. Se diventa necessario
                        modificare la stringa sul momento è necessario riassegnare il risultato alla variabile.
                        <br>
                        <div class="esempio">Es:
                            <br>let str = "Hello, World!";
                            <br>str = str.slice(0, 5); // Now, str is "Hello"
                        </div>
                        <br>N.B. anche per il metodo 'slice' se si omette il secondo parametro la sottostringa
                        includerà
                        i caratteri dall'inizio del index alla fine della stringa.
                    </li>
                    <br>
                    <li>'.substr (start, length)':
                        <br>è usato per estrarre una sottostringa da una stringa, inizia da un index specifico e si
                        estende per un certo numero di caratteri.
                        <br>questo metodo prende due parametri; l'inizio dell'index e la lunghezza della
                        sottostringa.
                        <br>
                        <div class="esempio">Es:
                            <br>let str = "Hello, World!";
                            <br>let subStr = str.substr(0, 5); // Returns "Hello"
                        </div>
                        In questo esempio il metodo 'substr' parte dall'indice 0 e estrae una sottostringa lunga 5
                        caratteri, per l'appunto 'hello', quindi possiamo notare che il seocndo parametro non è la
                        l'indice di fine ma la lunghezza della sottostringa.
                        <br>Come per 'slice' anche 'substr' se gli si mette un indice negativo inizierà a contare
                        dalla fine della stringa
                        <br>
                        <div class="esempio">Es:
                            <br>let str = "Hello, World!";
                            <br>let subStrEnd = str.substr(-6); // Returns "World!"
                        </div>
                        <br>Come per gli altri metodi elencati qui sopra anche 'substr' non modifica la stringa
                        originale, se diventa necessario
                        modificare la stringa sul momento è necessario riassegnare il risultato alla variabile.
                        <br>
                        <div class="esempio">Es:
                            <br>let str = "Hello, World!";
                            <br>str = str.substr(0, 5); // Now, str is "Hello"
                        </div>
                    </li>
                </ul>
                È importante sapere che 'substr' è considerato il metodo meno versatile rispetto a 'slice' e
                'substring' e anche per qeusto il meno usato, difatti questi ultimi due sono i metodi più flessibili
                e largamente usati in modo particolare 'slice'. Questo perchè 'slice' è per la maggior parte dei
                casi il metodo più flessibile e con un comportamento coerente.
            </li>
            <br>
            <li>Concatenazione delle stringhe:
                <br> per concatenare le stringhe ci sono 2 metodi:
                <ul type="A">
                    <li>Usare l'operatore '+':
                        <br>
                        <div class="esmepio">Es:
                            <br>var string1 = "Hello";
                            <br>var string2 = " World";
                            <br>var result = string1 + string2;
                            <br>console.log(result); // Output: Hello World
                        </div>
                        <br>Come possiamo vedere nell'esempio l'operatore '+' è usato per concatenare i conetnuti
                        della 'string1' e 'string2', risultando cosi una nuova stringa.
                        <br id="plusmulti"><a href="#mp" target="_self">Possiamo concatenare stringhe multiple
                            usando più operatori '+'.</a>
                        <br>
                        <div class="esempio">Es:
                            <br>var string1 = "Hello";
                            <br>var string2 = " beautiful";
                            <br>var string3 = " World";
                            <br>var result = string1 + string2 + string3;
                            <br>console.log(result); // Output: Hello beautiful World
                        </div>
                    </li>
                    <li>'.concant()' method:
                        <br>Questo è l'altro metodo per concatenare le stringhe.
                        <br>
                        <div class="esempio">Es:
                            <br>var string1 = "Hello";
                            <br>var string2 = " World";
                            <br>var result = string1.concat(string2);
                            <br>console.log(result); // Output: Hello World
                        </div>
                        <br>Possiamo vedere nell'esempio che il metodo '.concat' è stato usato sulla string1, mentre
                        la string2 è stata messa tra le parentesi tonde,come argomento.
                        <br>Quindi questo metodo restituisce una nuova stringa che è la concatenazione delle due
                        stringhe originali.
                        <br id="concatmulti"><a href="#mp" target="_self">Come per l'operatore 'Più' anche il metodo
                            .'concat' consente di concatenare stringhe
                            multiple, fancedole passare come argomento nel metodo '.concat'.</a>
                        <br>
                        <div class="esempio">Es:
                            <br>var string1 = "Hello";
                            <br>var string2 = " beautiful";
                            <br>var string3 = " World";
                            <br>var result = string1.concat(string2, string3);
                            <br>console.log(result); // Output: Hello beautiful World
                        </div>
                        Quindi possiamo constatare che ad una prima occhiata sia l'operatore 'Più' che il metodo
                        concat siano simili, ma hanno delle differenze:
                        <br>inazzitutto la immutabilità, ovvero il metodo 'concat' crea una nuova stringa per
                        concatenazione delle strignhe estistenti e quelle origininali non vengono cambiate.
                        Invece l'operatore 'Più' crea una nuova stringa e qeulle origininali non sono modificate.
                        <br id="mp"><a href="#concatmulti, #plusmulti" target="_self">Le concatenazioni multiple
                            (gia viste sopra).</a>
                        <br>Ma la differenza vera e proria è la leggibilità:
                        <ul>
                            <li>il metodo '.concat()', per alcuni sviluppatori, è il più leggibile specialmente
                                quando si concatenano stringhe multiple.</li>
                            <li>l'operatore '+' è conciso e familiare, ma la leggibilità potrebbe decrescere quando
                                si concatenano più di 2 stringhe </li>
                        </ul>
                    </li>
                    <li>Un altro metodo è il '+=':
                        <br>fa la stessa cosa dell'operatore '+'.
                        <br>
                        <div class="esempio">Es:
                            <br>let str ="this is first sentence. "
                            <br>let str2 = "this is second sentence."
                            <br>str+=str2
                            <br>console.log(str+=str2)
                        </div>
                        Come Possiamo vedere l'operatore '+=' è stato usato per concatenare la variabile 'str1' con
                        la
                        variabile 'str2'. Questo è equivalente a scrivere 'str1=str1 + str2.'
                        <br>Come per gli altri metodi si possono concatenare molteplici stringhe.
                        <br>
                        <div class="esempio">Es:
                            <br>var string1 = "Hello";
                            <br>var string2 = " beautiful";
                            <br>var string3 = " World";
                            <br>string1 += string2 + string3;
                            <br>console.log(string1); // Output: Hello beautiful World

                        </div>
                    </li>
                </ul>
            </li>
            <br>
            <li>Interpolazione delle stringhe:
                <br>le Interpolazione delle stringhe possono essere fatte usando i cosiddetti 'Template literals',
                che furono indrotti dal ECMAscript6(o ES6).
                <br>Forniscono un modo più conciso e flessibile per creare delle stringhe che includono variabili o
                espressioni. Quindi proveddono a creare stringhe di espressioni incorporate in modo più leggibile e
                pratico.
                La struttura dei 'Template literals' è la seguente:
                <br>- per creare un Template bisogna usare le backsticks(``) come delimitatori, poiche proprio i
                template Literal sono inclusi dalle backsticks .
                <br>- la sintassi è:
                <br>
                <div class="esempio"> Es:
                    <br>let variable = "world";
                    <br>let templateLiteral = `Hello, ${variable}!`;
                    <br>console.log(templateLiteral)//Output: Hello world
                </div>
                In questo esempio possiamo vedere che la variabile 'variable' è stata messa dentro un placeholder
                (${} →
                i placeholder in js ) dove per la variabile a cui è assegnata la stringa world viene interpolata in
                una
                nuova stringa.
                <br> I template literals hanno varie funzioni:
                <ul type="A">
                    <li>Expression interpolation:
                        <br>Ogni espressione, funzione, variabile, etc. valida può essere inclusa dentro un
                        placeholder '${}' per essere valutata e interpolata in una stringa.
                        <br>
                        <div class="esempio">Es:
                            <br>const x = 5;
                            <br>const y = 10;
                            <br>const sum = `The sum of ${x} and ${y} is ${x + y}.`;
                        </div>
                    </li>
                    <br>
                    <li>Multi-line strings:
                        <br>I template literals supportano le stringhe multi linea, rendendo facile creare stringhe
                        che si
                        estendono su più righe senza la necessita di usare concatenazioni o escape characters.
                        <br>
                        <div class="esempio">Es:
                            <br>const multiLineString = `
                            <br>This is a multi-line
                            <br>string using template literals.
                            <br>It allows for easy string interpolation
                            <br>and supports line breaks.
                            <br>`;
                            <br>console.log(multiLineString);
                        </div>
                        In questo esempio le stringhe sono definite tra le backsticks, mentre le linee di
                        indentazione e le interuzzioni di riga tra i template literal sono preservate nella stringa
                        risultante.
                        <br>Prima dell'introduzione dei template literal nel ECMAScript 6 (ES6), creare le stringhe
                        multi linea in javascript includeva usare l'operatore di concatenazione ('+') o i caratteri
                        degli escape newline. Per questo i template literal semplificano questo processo e
                        migliorano la leggibilità del codice.
                    </li>
                    <br>
                    <li>Tagged Templates(Advanced):
                        <br>i template literal possono essere usati con uno speciale tipo di funzione chiamata "tag
                        function". Questa funzione permette di manipolazione più avanzata dei template literal.
                        <br>In sostanza questa funzione riceve i valori letterali di una stringa e le espressioni
                        valutate come argomenti, permettendo un opportunità per costumizzare il comportamento dei
                        template literal.
                        Il tag function è posto prima del template literal ed usa la seguente sintassi:
                        <br>
                        <div class="esempio">Es:
                            <br>function myTagFunction(strings, ...values) {
                            <br>// Custom logic using the strings and values
                            <br>// Return the final processed string
                            <br>}
                            <br>const result = myTagFunction`Hello, ${name}!`;
                        </div>
                        <b>'myTagFunction'</b> è il tag function, riceve un array <b>'strings'</b> contenente la
                        stringa letteralee una lista di <b>'values'</b> che allora volta contengono le espressioni
                        valutate.
                        <br>Per fare un esempio più dettagliato:
                        <br>
                        <div class="esempio">Es:
                            <br>function currencyFormatter(strings, ...values) {
                            <br>const formattedValues = values.map((value, index) => {
                            <br>if (typeof value === 'number') {
                            <br>return `$${value.toFixed(2)}`;
                            <br>}
                            <br>return value;
                            <br>});
                            <br>return strings.reduce((result, string, index) => {
                            <br>return result + string + (formattedValues[index] || '');
                            <br>}, '');
                            <br>}
                            <br>const price = 42.5;
                            <br>const product = 'Book';
                            <br>const formattedString = currencyFormatter`The price of the ${product} is ${price}.`;
                            <br>console.log(formattedString);
                        </div>
                        In questo esempio <b> 'currencyFormatter' </b> è un tag function che formatta valori
                        numerici come valuta.
                        Il template literal inclusde un nome prodotto e un prezzo. Il tag function processa il
                        template literal, formatta il valore numerico come valuta, e restituisce la stringa finale.
                        <br>Come possiamo ben vedere il tagged template è una carrateristica molto utile,
                        specialmente quando si ha a che fare con Requisiti di internazionalizzazione, sicurezza o
                        formattazione personalizzata. Forniscono un modo per separare i problemi e gestire
                        l'elaborazione dei template literals in modo modulare e riutilizzabile.
                    </li>
                </ul>
                <!-- relative about template literal function -->
                <div class="info">
                    <img src="/Media/Photo/lente di ingradimento.jpg" height="40px" width="50px" alt="">
                    <p>
                        il termine placeholder può riferirsi a diverse cose, pertanto dipende dal contesto.
                        Nel contesto del form <!--modulistica in italiano?--> di Html un placeholder è spesso
                        associato con il 'placeholder' attribute.
                        <br>Questo attributo viene usato in un input fields che fornisce un breve suggerimento che
                        descriva il valore previsto del campo di input.
                        <br>È tipicamente visualizzato con il colore grigio chiaro e segue spesso l'attributo di
                        tipizzazione.
                    <div class="esempio">Es:
                        <br>--input type="text" placeholder="Enter your name"--
                    </div>
                    <br>Come possiamo vedere nel tag input sono stati aggiunti gli attributi di type e placeholder,
                    "Enter your name" è il placeholder di testo.
                    <br>In javascript, invece, il termine placeholder è tipicamente riferito a un valore o contenuto
                    temporaneo che viene usato come sostituto per il valore/contentuto effetivo che verrà fornito o
                    generato in un secondo momento. Quindi è tipicamente riferito a un valore temporaneo o un testo
                    che è usato come un tipo di "stand-in" o una rappresentzaione iniziale per un data input o un
                    elemento di una pagina web.
                    <ul>
                        <li>
                            Template Engines:
                            <br>quando si lavora con un template engines nei frameworks di web development, i
                            placeholder sono spesso usati per rappresentare dati dinamici che vengono sostituiti nel
                            momento di esecuzione.
                            <br>Per l'istanza, in un template, si potrebbe avere un placeholder come '{{username}}',
                            è questo verra sostituito con l'usename attuale quando si farà il rendering della
                            pagina.
                            <br>[n.d.r Per maggiore chiarezza un template engines in js sono strumenti che aiutano i
                            developers a generare markup html in modo dinamico utilizzando i template.
                            <br> Questi strumenti <!--=engines?--> ti permettono di definire i placeholder nel
                            documento Html e dopo sostituirli con i valori o contentuti attuali durante il momento
                            di esecuzione.
                            Tutto ciò è particolarmtente utile quando si ha un contentuto dinamico che necessita di
                            essere inserito in una pagina web.]
                        </li>
                        <br>
                        <li>String Formatting:
                            <br>I placeholder possono anche essere usati per la formattazzione delle stringhe per
                            creare una stringa dinamica
                            <br>
                            <div class="esempio">
                                Es:
                                <br>var firstName = "John";
                                <br>var lastName = "Doe";
                                <br>var fullName = `${firstName} ${lastName}`;
                            </div>
                            Come possiamo vedere da questo esempio ${firstName} e ${lastName} agiscono come
                            placeholder che verrano sostituiti con i valori attuali quando la stringa è stata
                            valutata.
                            <br>Quindi i placeholder nei template literal sono contenitori dove inserire delle
                            variabili ed espressioni che verrano sostituite un fase di esecuzione dopo essere
                            valutati.
                            <br>I placeholder nei template literal sono racchiusi in '${}'.
                            <br>
                            <div class="esempio">
                                Es:
                                <br>const a = 5;
                                <br>const b = 10;
                                <br>const result = `The sum of ${a} and ${b} is ${a + b}.`;
                                <br>console.log(result); // Outputs: The sum of 5 and 10 is 15.
                            </div>
                            Come possiamo notare nell'esempio i placeholder '${a}', '${b}', '${a + b}' valutano le
                            variabili più le espressione e inseriscono il risultato nella stringa di template.
                            <br>In sostanza i placeholder nei template literals sono utili per creare stringhe
                            dinamiche in javascript, specialmente quando si costruiscono stringhe che dipendono da
                            valori di variabili o espressioni.
                        </li>
                        <br>
                        <li>Dynamic Content Loading:
                            <br>Quando carichiamo dinamicamente il contenuto in una pagina web, i placeholder
                            potrebbero essere usati inizialmente per rappresentare il contenuto che verrà inserito.
                            <br>Così il contentuto diventerà disponibile, e sostuisce il placeholder.
                            <br>[n.d.r. Per maggiore chiarezza il Dinamic content loading in js sono dei
                            placeholder(loading spinner o loading skeleton)
                            che vengono visualizzati mentre il contenuto viene recuperato da un server o caricato
                            dinamicamente, forniscono un feedback visivo all'utente. ]
                        </li>
                    </ul>
                    <!-- relative about definition and usage of a placeholder in js -->
                    </p>
                </div>
                <!-- relative about Js placeholder -->
            </li>
            <br>
            <li id="bN">Trovare i caratteri con la bracket notation ([]):
                <br>per ottenere un carattere in un indice specifico all'interno della stringa abbiamo visto i due
                metodi per eccellenza; ovvero <a href="#charAt" target="_blank">'charAt'</a> e <a
                    href="#charCodeAt">'charCodeAt'</a>, ma c'è un altro modo per fare ciò ovvero usare le bracket
                notation[].
                <br>
                <div class="esempio"> Es:
                    <br>let str=`Hello World`
                    <br>let bracketNot = str[0]
                    <br>console.log(bracketNot)//Output: `H`
                </div>
                N.B. Anche in questo caso l'indicizzazione parte da 0.
                <br>La differerenza tra il 'charAt', 'charCodeAt' e le bracket notation è:
                <ul>
                    <li> 'charAt': restituisce una stringa che contiene il carattere a uno specifico index nella
                        stringa originale </li>
                    <br>
                    <br>
                    <div class="esempio">Es:
                        <br>let str = "Hello";
                        <br>let character = str.charAt(1); // Returns the character at index 1
                        <br>console.log(character); // Outputs: e
                    </div>
                    <br>
                    <li> 'charCodeAt': restituisce un numero che rappresenta il valore di Unicode (UTF-16 code unit)
                        del carattere allo specifico index nella stringa originale </li>
                    <br>
                    <br>
                    <div class="esempio">Es:
                        <br>let str = "Hello";
                        let unicodeValue = str.charCodeAt(1); // Returns the Unicode value of the character at index
                        1
                        console.log(unicodeValue); // Outputs: 101 (Unicode value for 'e')
                    </div>
                    <br>
                    <li>bracket notation []: se l'index è tra il range valido della stringa, restituisce il
                        carattere in corrispondeza di tale stringa </li>
                    <br>
                    <br>
                    <div class="esempio">Es:
                        <br>let str = "Hello";
                        <br>let character = str[1]; // Returns the character at index 1
                        <br>console.log(character); // Outputs: e
                    </div>
                    <br>Tuttavia, se l'index è al di fuori del range, ritorna 'undefined'
                    <br>let str = "Hello";
                    <br>let outOfRange = str[10]; // Index 10 is out of range
                    <br>console.log(outOfRange); // Outputs: undefined
                </ul>
                Questo perchè: <b>'string[x]'</b> restituisce il carattere nella posizione x in string, se x è un
                numero intero compreso tra 0 e string.length-1, in caso contrario restituisce 'undefined'.
                <!-- Da chiarire -->
                <br>'.charAt()' è migliore dal punto di vista della compatibilità se la compatibilità IE6/IE7 (IE =
                Internet Explorer ) è richiesta.
                <br>Le bracket notation sono un modo moderno con il quale lavorare e sono compatibili con IE8+ e
                tutti gli altri browser (tutti i microsoft Edge/Firefox/Chrome/Safari 2+/, tutti i sistemi
                iOS/Android).
                <!-- relative about difference 'charAt', 'charCodeAt' and bracket notation -->
            </li>
            <br>
            <li>toUpperCase() and toLowerCase() methods:
                <br>Sono due metodi usati per convertire il case di una stringa
                <ul type="A">
                    <li>il '.toUpperCase()' è un metodo usato per convertire tutti i caratteri in maiuscolo in una
                        stringa.
                        <br>Non modifica la stringa originale ma restituisce una nuova stringa con i caratteri
                        convertiti in maiuscolo.
                        <br>
                        <div class="esempio">
                            Es:
                            <br>let originalString = "Hello, World!";
                            <br>let uppercaseString = originalString.toUpperCase();
                            <br>console.log(uppercaseString); // Output: "HELLO, WORLD!"
                            <br>console.log(originalString); // Output: "Hello, World!" (original string is
                            unchanged)
                        </div>
                    </li>
                    <br>
                    <li> '.toLowerCase()':
                        <br>è un meotodo che converte tutti i caratteri in minuscolo in una stringa.
                        <br>Come per il '.toUpperCase', non modifica la stringa originale ma retituisce una nuova
                        stringa con tutti i caratteri convertiti in minuscolo
                        <br>
                        <div class="esempio">
                            Es:
                            <br>let originalString = "Hello, World!";
                            <br>let lowercaseString = originalString.toLowerCase();
                            <br>console.log(lowercaseString); // Output: "hello, world!"
                            <br>console.log(originalString); // Output: "Hello, World!" (original string is
                            unchanged)
                        </div>
                    </li>
                    <br>
                </ul>
                Questi metodi sono utili quando si vuole comparare o manipolare le stringhe senza considerare il
                case sensitivity. Bisogna tenere a mente che questi metodi non cambiano la stringa originale:
                restituiscono una nuova stringa con il case desiderato.
                <br>Se si desidera modificare la stringa originale, è necessario riassegnare il risultato alla
                variabile, come illustrato negli esempi.
            </li>
            <br>
            <li>Trovare le sottostringhe:
                <br> IN javascript si possono trovare le sottostringhe in una stringa usando diversi metodi
                <ul type="A">
                    <li>'.IndexOf(searchValue[, startIndex]):'
                        <br> Questo metodo restituisce l'indice della prima occorenza in una specifica sottostringa.
                        Se la sottostringa non viene trovata, ritorna a -1.
                        <br>
                        <div class="esempio">Es:
                            <br>let mainString = "Hello, World!";
                            <br>let substring = "World";
                            <br>if (mainString.indexOf(substring) !== -1) {
                            <br>console.log("Substring found!");
                            <br>} else {
                            <br>console.log("Substring not found.");
                            <br>}
                        </div>
                        La sintassi di questo metodo prevede che come argomento vengano indicati
                        <ul>
                            <li id="searchValue">'searchValue': il valore da cercare nella stringa</li>
                            <br>
                            <li id="startIndex"> 'startIndex'(opzionale): L'index al quale inizia la ricerca. Se
                                questo valore viene
                                omesso, la ricerca inizia dall'inizio della stringa. </li>
                            <br>
                            <br>
                            <div class="esempio">Es:
                                <br>let str = "Hello, World!";
                                <br>let indexOfWorld = str.indexOf("World");
                                <br>console.log(indexOfWorld); // Output: 7
                            </div>
                            Ovviamente si può usare il metodo 'IndexOf' per trovare più occorrenze fornendo un
                            indice iniziale
                            <br>
                            <br>
                            <div class="esempio">Es:
                                <br>let str = "Hello, Hello, World!";
                                <br>let indexOfHello = str.indexOf("Hello");
                                <br>console.log(indexOfHello); // Output: 0
                                <br>// Find the second occurrence starting from index 1
                                <br>indexOfHello = str.indexOf("Hello", 1);
                                <br>console.log(indexOfHello); // Output: 7
                            </div>
                            Come ultima cosa va detto che questo metodo è case-sensitive, quindi nel caso si avesse
                            il bisogno di fare una ricerca senza maiuscole o minuscole (da d'ora in poi userò la
                            parola case-insesitive) si possono convertire sia la stringa che il valore di ricerca
                            utilizzando sia i metodi 'toLowerCase' o 'toUpperCase' prima del metodo 'indexOf'
                    </li>
                    <br>
                    <li>metodo '.includes()':
                        <br>restituisce un valore booleano che indica se una stringa contiene una sottostringa
                        specificata.
                        <br>Più precisamente è usato per controllare se una stringa contiene una specifica
                        sottostringa o carattere e restituisce un valore booleano indicando se la sottostringa è
                        stata trovata oppure no.
                        <br>Anche la sintassi di questo metodo è simile al metodo predendente ('.indexOf()')
                        <br>
                        <div class="esempio">Es:
                            <br>string.includes(searchValue[, startIndex]);
                        </div>
                        <ul>
                            <a href="#searchValue" target="_blank">
                                <li>'searchValue'</li>
                            </a>
                            <br>
                            <a href="startIndex" target="_blank">
                                <li>'startIndex'(opzionale)</li>
                            </a>
                            <br>
                            <br>
                            <div class="esempio">Es:
                                <br>let str = "Hello, World!";
                                <br>if (str.includes("World")) {
                                <br>console.log("Substring found!");
                                <br>} else {
                                <br>console.log("Substring not found.");
                                <br>}
                            </div>
                        </ul>
                        <br>In questo esempio il metodo 'includes()' è usato per controllare se la stringa 'Hello
                        World' contiene la sottostringa 'World'.
                        <br>Se viene trovata la sottostringa l'output sarà 'Substring found'.
                        <br>Come per il metodo 'IndexOf()' anche il metodo 'includes()' è case-sensitive.
                        <br>
                        <div class="esempio">Es:
                            <br>let str = "Hello, World!";
                            <br>if (str.includes("world")) {
                            <br>console.log("Substring found!");
                            <br>} else {
                            <br>console.log("Substring not found.");
                            <br>}
                        </div>
                        <br>Difatti nell'esempio la sottostringa 'world' non viene trovata poichè è diversa da
                        'World'
                        <br>Si può anche usare il metodo 'includes()' con un starting index
                        <br>
                        <div class="esempio">Es:
                            <br>let str = "Hello, Hello, World!";
                            <br>if (str.includes("Hello", 1)) {
                            <br>console.log("Substring found!");
                            <br>} else {
                            <br>console.log("Substring not found.");
                            <br>}
                        </div>
                        <br>In questo esempio, inizia a cercare "Hello" dall'indice 1 e, poiché trova una seconda
                        occorrenza, l'output sarà "Substring found!".
                        Quindi in sostanza Il metodo 'includes()' è un modo pratico per eseguire semplici controlli
                        delle sottostringhe senza bisogno delle informazioni sull'indice restituite da metodi come
                        'indexOf()'.
                    </li>
                    <br>
                    <li>Usare espressioni regolari:
                        <br>In javascript si possono usare espressioni regolari per trovare le sottostringhe usando
                        i metodi 'test()' o 'match()'
                        <ul type="A">
                            <li>Il metodo 'test()':
                                <br>il metodo 'test()' è un metodo RegExp(='Regular Expression') che verifica la
                                presenza di una corrispondenza
                                in una stringa. Restituisce 'true' se un match è stato trovato o 'false' in caso
                                contrario
                                <br>
                                <div class="esempio">Es:
                                    <br>let str = "Hello, World!";
                                    <br>let substringPattern = /World/;
                                    <br>if (substringPattern.test(str)) {
                                    <br>console.log("Substring found!");
                                    <br>} else {
                                    <br>console.log("Substring not found.");
                                    <br>}
                                </div>
                                <br>In questo esempio l'espressione regolare '/World/' è usata per verificare se la
                                stringa contiene la sottostringa 'World'. Se la verifica ha avuto successo, stampa
                                'Substring Found!'.
                            </li>
                            <br>
                            <li>Il metodo 'match()':
                                <br> Questo metodo recupera il risultato della corrispondenza di una stringa con
                                un'espressione regolare.
                                <br>Se la corrispondenza è stata trovata, restituisce un array contenente la stringa
                                corrispondente e tutti i gruppi catturati
                                <br>
                                <div class="esempio">Es:
                                    <br>let str = "Hello, World!";
                                    <br>let substringPattern = /World/;
                                    <br>let matchResult = str.match(substringPattern);
                                    <br>if (matchResult) {
                                    <br>console.log("Substring found: " + matchResult[0]);
                                    <br>} else {
                                    <br>console.log("Substring not found.");
                                    <br>}
                                </div>
                                <br>In questo esempio l'espressione regolare '/World/' è usata con im emetodo
                                'match()'.Se una corrsipondenza è stata trovata, stampa la sottostringa
                                corrispondente
                            </li>
                            <br>Le espressioni regolari offrono potenti funzionalità di corrispondenza dei modelli e
                            possono essere personalizzate per ricerche di sottostringhe più complesse.
                        </ul>
                        <!--Tue 28/11/23 10:49: relative about test and match method -->
                    </li>
                    <br>
                    <li>'lastOfIndex(substring)': Restituisce l'indice dell'ultima occorrenza di una sottostringa
                    </li>
                    <br>
                </ul>
                <!-- Tue 28/11/23 10:49: relative about to find substrings -->
            </li>
            <br>
            <li>Replacing a substring:
                <br>il metodo 'replace()' scambia una stringa con un altra alla sua prima occorenza, cioè è
                sensibile
                alle maiuscole (case sensitive).
                <br>
                <div class="esempio">Es:
                    <br>let originalString = "Hello, World!";
                    <br>let substringToReplace = "World";
                    <br>let replacementString = "Universe";
                    <br>let newString = originalString.replace(substringToReplace, replacementString);
                    <br>console.log(newString);
                </div>
                <br>In questo esempio il metodo 'replace' è chiamato su 'originalString' con 2 argomenti: il
                'substringToReplace' e il 'replacementString'. Il metodo restituisce una nuova stringa dove la prima
                occorenza della 'substringToReplace' è swcambiata con 'replacementString'.
                <br>Anche qui si possono usare espressioni regolari come
                <ul type="A">
                    <li>'/g':
                        <br>ogni volta che trova il primo argomento lo sostituisce con il secondo argomento
                        <br>
                        <div class="esempio">Es:
                            <br>let originalString = "Hello, World! World is amazing.";
                            <br>let substringToReplace = /World/g;
                            <br>let replacementString = "Universe";
                            <br>let newString = originalString.replace(substringToReplace, replacementString);
                            <br>console.log(newString);
                        </div>
                        <br>In questo esempio, l'espressione regolare /World/g viene utilizzata per sostituire tutte
                        le occorrenze di "World" nella stringa con "Universe". Il flag g è global scope, il che
                        significa che sostituirà tutte le occorrenze, non solo la prima.
                    </li>
                    <br>
                    <li>'/i':
                        <br>ignora il case sensitive.
                    </li>
                    <br>
                </ul>
            </li>
            <br>
            <li>Splittare le stringhe:
                <br>il metodo 'split()' ritorna un array di stringhe composto da tutte le sottostringhe separate dal
                carattere immesso nell'argomento.
                <br>Per fare un esempio:
                <br>
                <div class="esempio">Es:
                    <br>let originalString = "apple,orange,banana";
                    <br>// Split the string using a comma as the delimiter
                    <br>let arrayOfStrings = originalString.split(',');
                    <br>console.log(arrayOfStrings);
                </div>
                <br>in questo esempio, il metodo 'split' è chiamato su 'originalString', e le virgolotte sono messe
                tra le parestesi tonde come argomento. Il risultato è quindi un array dei tre elementi ('apple',
                'orange', 'banana').
                <br>Posso usare anche delimitatori diversi come ad esempio:
                <br>
                <div class="esempio">Es:
                    <br>let originalString = "apple;orange;banana";
                    <br>// Split the string using a semicolon as the delimiter
                    <br>let arrayOfStrings = originalString.split(';');
                    <br>console.log(arrayOfStrings);
                </div>
                <br>In questo caso la stringa è splittata usando il punto e virogla come delimitatore.
                <br>Se si vuole splittare una stringa in un carattere individuale, si può usare una stringa vuota
                come delimitatore.
                <br>
                <div class="esempio">Es:
                    <br>let originalString = "hello";
                    <br>// Split the string into an array of characters
                    <br>let arrayOfCharacters = originalString.split('');
                    <br>console.log(arrayOfCharacters);
                </div>
                <br>In questo caso l'output sarà un array dei caratteri che compongono la parola 'hello'.
            </li>
            <br>
            <li>il metodo 'trim()':
                <br>è usato per rimuovere gli spazi bianchi(spazi, schede, interruzioni di riga) da entrambe le
                estremità di una stringa.
                <br>
                <div class="esempio">Es:
                    <br>let stringWithWhitespace = " Hello, World! ";
                    <br>// Using trim to remove leading and trailing whitespace
                    <br>let trimmedString = stringWithWhitespace.trim();
                    <br>console.log(trimmedString);
                </div>
                <br>In questo esempio il metodo 'trim' è chiamato per rimuovere gli spazi bianchi dalla stringa.
                è bene notare che il metodo 'trim' non modifica la stringa originale, restituisce una nuova stringa
                con gli spazi vuoti iniziali e finali rimossi.
                <br>Nel caso si vilesse eliminare gli spazi bianchi solo a destra (fine stringa) o sinistra (inizio
                stringa) si possono usare rispettivamente 'trimStart'(o 'trimLeft') e 'trimEnd'(o 'trimRight').
                Tuttavia questi metodi non sono così ampiamente supportati come 'trim', quindi generalemente è più
                sicuro usare 'trim' per la compatibilità cross-browser.
                <br>Nel work flow moderno si usano anche i metodi 'String.prototype.trimStart' e
                'String.prototype.trimEnd'.
            </li>
        </ol>
        <!-- THIS IS RELATIVE ABOUT STRINGS METHODS -->
        <h2>L'immutabilità delle stringhe </h2>
        Le stringhe in javascript, come già riportato più volte, sono immutabili; cioè <mark>una volta create non
            possono essere modificate</mark>. Ciò non significa che non possono essere cambiate, solo che i singoli
        caratteri di una stringa letterale non possono essere modificati.
        <br>Per fare un esempio:
        <br>
        <div class="esempio">Es:
            <br>//string immutability
            <br>let str = `Vello World`
            <br>str[0] = `H`
            <br>console.log(str[0])//Output : TypeError: 0 is read-only (/index.js:37)
        </div>
        Come possiamo vedere ci da errore poichè il singolo carattere non può essere cambiato una volta che la
        stringa è stata creata. Possiamo ancora cambiarlo in "hello world", ma <mark>non possiamo seplicemente
            cambiare una singola lettera in questo modo.</mark>
        Per fare ciò esistono due strade :
        <ul type="I">
            <li>Andare all'assegnazione del valore della variabile 'str'("vello world") e cambiare la lettera 'v' in
                'h' </li>
            <li>Oppure
                <br>
                <div class="esempio">Es:
                    <br>let str = `Vello World`
                    <br>str = `Hello World`
                    <br>console.log(str) //Output: `Hello World`
                </div>
            </li>
        </ul>
        <!-- Relative about the string immutability -->
        </p>
        <!-- Tue 28/11/23  12:58: Relative about strings paragraph-->
        <h2><a href="#objects" target="_self">Array</a></h2>
        <p>
            Gli array in javascript sono un tipo di struttura dati che permette di immagazzinare e manipolare una
            collezzione di elementi, si dichiarano come qualsisasi variabile ma per la precisione sono oggetti.
            <br>Gli array in javascript non sono dati primitivi ma sono invece array di oggetti con specifiche
            caratteristiche di base:
        <ul>
            <li>In Javascript gli array sono ridimensionabili e posso contenere un mix di differenti data types</li>
            <br>
            <li>Gli array di Javascript non sono array associativi, quindi non è possibile accedere agli elementi di un
                array usando una stringa arbitraria come indici, ma vi si accede tramite numeri interi positivi ([0, 1,
                2, etc.]) o le loro rispettive forma di stringa, come indici. </li>
            <br>
            <li>Gli array di Javascript sono zero-indexed; il primo elemento di un array si trova all'indice 0, il
                secondo all'indice 1 e cosi via. Di conseguenza l'ultimo elemento corrisponde al valore della proprietà
                '.length' dell'array meno 1. </li>
            <br>
            <li>Le operazioni di copia di array JavaScript creano copie superficiali(shallow copies). È bene sapere che
                tutte le operazioni di copia integrate standard con qualsiasi ogetto di javascript creano copie
                superficiali, piuttosto che copie profonde (deep copies).</li>
            <br>
        </ul>
        <!-- Thu 30/11/23  10:49: relative about arrays code characteristics-->
        <br>
        <div class="info">
            <img src="/Media/Photo/lente di ingradimento.jpg" height="40px" width="50px" alt="">
            <h3>Differenze tra shallow copies e deep copies</h3>
            <p>
                In Javascript, quando si lavora con gli array o gli oggetti, è importante compredere i concetti di
                shallow copies e deep copies. Questi concetti inoltre si applicano ad altri strutture di dati complessi
                come gli oggetti.
                <br>
            <ol type="1.">
                <li>Shallow copies</li>
                <ul>
                    <li>Una shallow copy crea un nuovo array o un oggetto, ma non crea nuove copie di un oggetto o array
                        nidificato all'interno della struttura originaria </li>
                    <br>
                    <li>I cambiamenti fatti per oggetti nidificati o array dentro la struttura copiata influenzerà sia
                        l'orignale che le versioni copiate </li>
                    <br>
                    <li>Gli operatori <b id="slice">'.slice()'</b>, <b id="concat">'.concat()'</b> e<b id="spread">
                            spread('...') </b> sono metodi comunemente usati per creare shallow copies di array.</li>
                    <br>
                    <br>
                    <div class="esempio">Es:
                        <br>const originalArray = [1, 2, [3, 4]];
                        <br>// Shallow copy using slice()
                        <br>const shallowCopy = originalArray.slice();
                        <br>// Shallow copy using spread operator
                        <br>const shallowCopy2 = [...originalArray];
                        <br>// Modifying the nested array in the shallow copy affects the original
                        <br>shallowCopy[2][0] = 99;
                        <br>console.log(originalArray); // [1, 2, [99, 4]]
                    </div>
                </ul>
                <!-- Thu 30/11/23  11.27: relative about shallow copies characteristics -->
                <li>Deep copy</li>
                <ul>
                    <li>Una deep copy crea una copia completamente indipendente dell'array originale, o dell'oggetto,
                        insieme a tutti i suoi oggetti o array nidificati.  </li>
                    <br>
                    <li>Modifiche apportate alla struttura copiata non influenzeranno l'originale e viceversa.  </li>
                    <br>
                    <li></li>
                    <br>
                </ul>
                <!-- Thu 30/11/23  11.42: relative about deep copy characteristics  -->
            </ol>
            </p>
        </div>
        <!-- Thu 30/11/23  11.16: relative about difference between shallow & deep copies -->
        <br>Gli array sono utili per elencare un elenco di prodotti in un carello o un elenco di colori che
        l'utente ha selezionato, di conseguenza per memorizzare questo elenco si usa un array.
        <br>Per diciharare un array si usano, come per le altre variabili <a href="#declare" target="_self">var, let
            e const</a>
        </p>
        <!-- Tue 28/11/23  12:59: Relative about arrays paragraph -->
    </div>
    <!-- Tue 28/11/23  12:58: Relative about all text-->

    </div>
    <!-- Tue 28/11/23  12:48: relative about text bound -->
</body>

</html>